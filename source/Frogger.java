/* autogenerated by Processing revision 1293 on 2024-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Frogger extends PApplet {

Player player;
ArrayList<Spawner> spawners = new ArrayList<Spawner>();
ArrayList<PVector> coins = new ArrayList<PVector>();
ArrayList<PVector> boosters = new ArrayList<PVector>();


int boosterDistance;
int boostStartY;
int spaceBetweenPaths = floor(random(2, 5));
int pathSize = 100;
int score;
int highscore;
int coinScoreAlpha;
int GameState;
int grassTileY;

PFont streetCredFont;

boolean playerIsBoosting;

public void setup() {
  /* size commented out by preprocessor */;

  grassTileY = height-50;

  LoadAllImages();
  LoadAllSounds();

  player = new Player();
  createNextSpawner(100);

  try {
    highscore = PApplet.parseInt(loadStrings("HIGHSCORE.txt")[0]);
  } 
  catch (NullPointerException e) {
    highscore = 0;
  }

  streetCredFont = createFont("street cred.ttf", 96);
  textFont(streetCredFont);
}

public void draw() {
  // Background (grass)
  imageMode(CENTER);
  for (int y=grassTileY; y>-50; y-=100) {
    for (int x=50; x<width; x+=100) {
      image(groundTileImgs[0], x, y);
    }
  }

  switch(GameState) {
  case 0:
    player.display();

    if (floor(PApplet.parseFloat(frameCount)/20) % 2 == 0) {
      fill(255, 0, 0);
    } else {
      fill(100, 0, 0);
    }
    textSize(70);
    textAlign(CENTER);
    text("Press 'UP'", width/2, height/2);
    break;
  case 1:
    moveWorldDown();
    player.update();

    for (int i=spawners.size()-1; i>=0; i--) {
      Spawner s = spawners.get(i);

      s.update();
      if (!playerIsBoosting) {
        s.checkCollisions();
      }

      if (s.goesOffscreen()) {
        spawners.remove(s);
      }
    }

    for (int i=boosters.size()-1; i>=0; i--) {
      PVector b = boosters.get(i);

      if (b.y > height + 25) {
        boosters.remove(b);
      }
    }

    for (int i=coins.size()-1; i>=0; i--) {
      PVector c = coins.get(i);

      if (c.y > height + 25) {
        coins.remove(c);
      }
    }

    DisplayEverything();

    Spawner topMostSpawner = spawners.get(0);
    for (Spawner s : spawners) {
      if (s.yLocation < topMostSpawner.yLocation) {
        topMostSpawner = s;
      }
    }
    if (topMostSpawner.yLocation >= pathSize*spaceBetweenPaths) {
      float topPathY = topMostSpawner.yLocation;
      int startY = 100 - floor(topPathY - pathSize*spaceBetweenPaths);
      spaceBetweenPaths = floor(random(2, 5));
      createNextSpawner(startY);
    }


    if (playerIsBoosting) {
      if ((boosterDistance-boostStartY)/ pathSize >= 100) {
        for (Spawner s : spawners) {
          if (s.containsPlayer()) {
            return;
          }
        }
        playerIsBoosting = false;
      }
    }
    break;
  case 2:
    DisplayEverything();

    if (floor(PApplet.parseFloat(frameCount)/20) % 2 == 0) {
      fill(255, 0, 0);
    } else {
      fill(100, 0, 0);
    }
    textSize(80);
    textAlign(CENTER);
    text("GAME OVER", width/2, height/2);
    text("Press 'r' to retry", width/2, height/2+100);
    break;
  }
}

public void moveWorldDown() {
  int speed = 2;
  if (player.location.y < 300) {
    speed = 5;
  }

  if (playerIsBoosting) {
    speed = pathSize;
    boosterDistance += speed;
    if ((boosterDistance-boostStartY) % pathSize == 0) {
      increaseScore(1);
    }
  } else {
    player.moveDown(speed);
  }
  for (Spawner s : spawners) {
    s.moveDown(speed);
  }

  for (PVector b : boosters) {
    b.y += speed;
  }

  for (PVector c : coins) {
    c.y += speed;
  }

  grassTileY += speed;
  if (grassTileY >= height+50) {
    grassTileY = height-50;
  }
}


public void DisplayEverything() {
  for (Spawner s : spawners) {
    s.display();
  }
  for (int i=0; i<boosters.size(); i++) {
    PVector b = boosters.get(i);
    pushMatrix();
    translate(b.x, b.y);
    float angle = PApplet.parseFloat(frameCount)/10 + i*2;
    rotate(sin(0.3f*angle)*cos(4*angle) * PI/5);
    image(jetpackImage, 0, 0);
    popMatrix();
  }
  for (int i=0; i<coins.size(); i++) {
    PVector c = coins.get(i);
    pushMatrix();
    translate(c.x, c.y);
    scale(sin((PApplet.parseFloat(frameCount)/10)+i)* 0.25f + 1.25f);
    image(coinImage, 0, 0);
    popMatrix();
  }

  player.display();

  // Score
  rectMode(CENTER);
  fill(0);
  stroke(255, 0, 0);
  strokeWeight(3);
  rect(width/2, 47, 205, 55, 7);
  rect(width/2, 100, 165, 45, 7);
  image(scoreTextImage, width/2, 50);
  textSize(47);
  textAlign(CENTER);
  fill(250, 225, 75);
  text(score, width/2, 115);

  // Highscore
  fill(0);
  rect(width-100, 100, 165, 65, 7);
  rect(width-100, 155, 135, 45, 7);
  image(highscoreTextImage, width-100, 100);
  fill(250, 225, 75);
  textSize(40);
  text(highscore, width-100, 167);

  // "+5" text for coins
  textSize(40);
  fill(250, 200, 60, coinScoreAlpha);
  text("+5", width/2 + 60, 107);
  if (coinScoreAlpha > 0) {
    coinScoreAlpha -= 5;
  }

  // Player's score tracker
  image(flagImage, 25, player.scoreTrackerY);
}

public void createNextSpawner(int startY) {
  int n = floor(random(1, 7));
  int numberOfSpawners = floor(random(1, 5));
  switch(n) {
  case 1:
    for (int i=0; i<numberOfSpawners; i++) {
      spawners.add(new ArrowTrap(-startY - (numberOfSpawners-1)*pathSize + i*pathSize));
    }
    break;
  case 2:
    for (int i=0; i<numberOfSpawners; i++) {
      spawners.add(new CrabSpawner(-startY - i*pathSize));
    }
    break;
  case 3:
    int previousMovementSpeed = 0;
    for (int i=0; i<numberOfSpawners; i++) {
      int movementSpeed = floor(random(3, 7));
      if (i != 0) {
        while (abs(previousMovementSpeed-movementSpeed) < 2) {
          movementSpeed = floor(random(3, 7));
        }
      }
      spawners.add(new River(-startY - i*pathSize, movementSpeed));
      previousMovementSpeed = movementSpeed;
    }
    break;
  case 4:
    for (int i=0; i<numberOfSpawners; i++) {
      spawners.add(new BoulderSpawner(-startY - i*pathSize));
    }
    break;
  case 5:
    for (int i=0; i<numberOfSpawners; i++) {
      spawners.add(new Road(-startY - i*pathSize));
    }
    break;
  case 6:
    for (int i=0; i<numberOfSpawners; i++) {
      spawners.add(new TrainTrack(-startY - i*pathSize));
    }
    break;
  }


  for (int i=spawners.size()-1; i>=spawners.size() - numberOfSpawners; i--) {
    spawners.get(i).quickUpdate();
  }

  if (random(1) < 0.5f) {
    int numberOfCoins = floor(random(1, numberOfSpawners));
    for (int i=0; i<numberOfCoins; i++) {
      coins.add(getPossibleLocation(numberOfSpawners));
    }
  }
  if (random(1) < 0.1f && !playerIsBoosting) {
    boosters.add(getPossibleLocation(numberOfSpawners));
  }
}

public void increaseScore(int amount) {
  // Increase the score by the given amount and check if it's a new highscore
  score += amount;
  if (score > highscore) {
    highscore = score;
    String[] s = {str(highscore)};
    saveStrings("HIGHSCORE.txt", s);
  }
}


public PVector getPossibleLocation(int numberOfSpawners) {
  float x = random(pathSize*2, width - pathSize*2);
  int chosenIndex = floor(random(numberOfSpawners));
  Spawner chosenSpawner = spawners.get(spawners.size()-chosenIndex-1);
  float y = chosenSpawner.yLocation;
  return new PVector(x, y);
}
class Obstacle {
  PVector location;
  int obstacleSize;
  int direction;
  int movementSpeed;

  Obstacle(float x, float y, int obstacleSize, int movementSpeed, int direction) {
    location = new PVector(x, y);
    this.obstacleSize = obstacleSize;
    this.direction = direction;
    this.movementSpeed = movementSpeed;
  }

  public void display() {
    fill(255, 0, 0);
    noStroke();
    ellipse(location.x, location.y, obstacleSize, obstacleSize);
  }

  public void moveDown(int speed) {
    location.y += speed;
  }

  public void update() {
    location.x += direction * movementSpeed;
  }

  public boolean isFinished() {
    if (direction == 1) 
      return location.x > width + obstacleSize/2;
    else if (direction == -1) 
      return location.x < -obstacleSize/2;

    return false;
  }

  public boolean hitsPlayer() {
    return PVector.dist(location, player.spriteLocation) <= obstacleSize/2;
  }
}


class Arrow extends Obstacle {
  Arrow(float x, float y, int direction) {
    super(x, y, 75, 10, direction);
  }

  public void display() {
    pushMatrix();
    translate(location.x, location.y);
    scale(direction * -1, 1);
    image(arrowImg,0,0);
    popMatrix();
  }

  public boolean hitsPlayer() {
    return player.spriteLocation.x < location.x + obstacleSize/2 &&
      player.spriteLocation.x > location.x - obstacleSize/2 &&
      player.spriteLocation.y < location.y + 10 &&
      player.spriteLocation.y > location.y - 10;
  }
}

class Crab extends Obstacle {
  float angle;
  Crab(float x, float y, int direction, int speed) {
    super(x, y, 50, speed, direction);
    angle = random(TWO_PI);
  }

  public void display() {
    pushMatrix();
    translate(location.x, location.y);
    rotate(sin(angle) * PI/10);
    scale(direction, 1);
    image(crabImg, 0,0);
    popMatrix();
  }

  public void update() {
    super.update();
    angle += 0.1f * movementSpeed;
  }
}


class Log extends Obstacle {
  PImage logImage;
  Log(float x, float y, int direction, int speed) {
    super(x, y, floor(random(1, 3)) * pathSize, speed, direction);
    
    if(obstacleSize == pathSize) {
      logImage = smallLogImage;
    } else {
      logImage = bigLogImage;
    }
  }
  

  public void display() {
    pushMatrix();
    translate(location.x, location.y);
    scale(direction * -1, 1);
    image(logImage, 0, 0);
    popMatrix();
  }

  public boolean hitsPlayer() {
    return player.spriteLocation.x < location.x + obstacleSize/2 &&
      player.spriteLocation.x > location.x - obstacleSize/2;
  }
}


class Boulder extends Obstacle {
  float angle;
  Boulder(float x, float y, int direction, int speed) {
    super(x, y, PApplet.parseInt(pathSize*0.8f), speed, direction);
  }

  public void display() {
    pushMatrix();
    translate(location.x, location.y);
    rotate(angle);
    image(boulderImg, 0, 0);
    popMatrix();
  }

  public void update() {
    super.update();
    angle += direction * 0.03f*movementSpeed;
  }
}


class Car extends Obstacle {
  PImage carImage;
  Car(float x, float y, int direction, int speed) {
    super(x, y, round(random(1, 2)) * 100, speed, direction);
    
    if(obstacleSize == 100) {
      carImage = smallCarImgs[floor(random(smallCarImgs.length))];
    } else {
      carImage = bigCarImgs[floor(random(bigCarImgs.length))];
    }
  }

  public void display() {
    imageMode(CENTER);
    pushMatrix();
    translate(location.x, location.y);
    scale(direction, 1);
    rotate(random(-0.02f, 0.02f) + HALF_PI);
    image(this.carImage, 0, 0);
    popMatrix();
  }

  public boolean hitsPlayer() {
    return player.spriteLocation.x < location.x + obstacleSize/2 &&
      player.spriteLocation.x > location.x - obstacleSize/2;
  }
}

class Train extends Obstacle {
  PImage trainImage;
  Train(float x, float y, int direction) {
    super(x, y, 1000, 50, direction);
    
    trainImage = trainImgs[floor(random(4))];
  }

  public void display() {
    rectMode(CENTER);
    pushMatrix();
    translate(location.x, location.y);
    scale(direction, 1);
    image(trainImage,0,0);
    popMatrix();
  }

  public boolean hitsPlayer() {
    return player.spriteLocation.x < location.x + obstacleSize/2 &&
      player.spriteLocation.x > location.x - obstacleSize/2;
  }
}
class Player {
  PVector location;
  PVector spriteLocation;
  PVector direction;

  int scoreTrackerY;

  Player() {
    location = new PVector(width/2, height-200);
    scoreTrackerY = PApplet.parseInt(location.y);
    spriteLocation = location.copy();
    direction = new PVector(0, -1);
  }

  public void display() {
    // Display the sprite (it's not at the true location of the player)
    pushMatrix();
    translate(spriteLocation.x, spriteLocation.y);
    rotate(3*HALF_PI);
    rotate(direction.heading());
    scale(2);
    if (playerIsBoosting) {
      float sinValue = sin(PApplet.parseFloat(boosterDistance - boostStartY)/3160);
      scale(sinValue + 1);
      rotate(sinValue * TWO_PI);
    }
    if (PVector.dist(location, spriteLocation) < 5) {
      image(froggerIdleImg, 0, 0);
    } else {
      image(froggerJumpImg, 0, 0);
    }
    popMatrix();
  }

  public void moveDown(int speed) {
    location.y += speed;
    spriteLocation.y += speed;
    scoreTrackerY += speed;
  }

  public void move(int xDirection, int yDirection) {
    if (playerIsBoosting)
      return;
    // If the player were to move outside of the screen from the left or right,
    // leave the function
    if (xDirection == -1 && location.x-pathSize <= 0) {
      return;
    } else if (xDirection == 1 && location.x+pathSize >= width) {
      return;
    }

    // If the player were to move outside of the screen from top,
    // leave the function
    if (yDirection == -1 && location.y - pathSize <= 0) {
      return;
    }


    direction = new PVector(xDirection, yDirection);
    location = PVector.add(location, direction.copy().mult(pathSize));
    if (location.y < scoreTrackerY) {
      increaseScore(1);
    }
  }

  public void update() {
    spriteLocation.lerp(location, 0.3f);

    if (spriteLocation.y > height + 20) {
      GameState = 2;
    }

    if (spriteLocation.x < -20 || spriteLocation.x > width+2) {
      GameState = 2;
    }

    if (!playerIsBoosting) {
      // Collect coins
      for (int i=coins.size()-1; i>=0; i--) {
        PVector c = coins.get(i);

        if (PVector.dist(spriteLocation, c) <= 40) {
          increaseScore(5);
          coinScoreAlpha = 255;
          coins.remove(c);
        }
      }


      // Collect boosters
      if (!boosters.isEmpty()) {
        PVector booster = boosters.get(0);
        if (PVector.dist(spriteLocation, booster) <= 50) {
          playerIsBoosting = true;
          boostStartY = PApplet.parseInt(location.y);
          boosterDistance = boostStartY;
          boosters.remove(booster);
        }
      }
    }
    if (spriteLocation.y < scoreTrackerY) {
      scoreTrackerY = PApplet.parseInt(spriteLocation.y);
    }
  }
}
PImage boulderImg;
PImage arrowImg;
PImage arrowDispenserImg;
PImage froggerIdleImg;
PImage froggerJumpImg;
PImage crabImg;
PImage roadImg;
PImage smallLogImage;
PImage bigLogImage;
PImage coinImage;
PImage jetpackImage;
PImage trainSignalImage;
PImage trainSignalLightImage;
PImage flagImage;
PImage scoreTextImage;
PImage highscoreTextImage;


PImage[] smallCarImgs = new PImage[6];
PImage[] bigCarImgs = new PImage[3];
PImage[] groundTileImgs = new PImage[6];
PImage[] trainImgs = new PImage[4];
PImage[] gardenStuffImages = new PImage[9];


public void LoadAllImages() {
  boulderImg = loadImage("Images/boulder.png");
  boulderImg.resize(PApplet.parseInt(pathSize*0.8f), PApplet.parseInt(pathSize*0.8f));

  arrowImg = loadImage("Images/arrow.png");
  arrowImg.resize(75, 20);

  arrowDispenserImg = loadImage("Images/arrowDispenser.png");
  arrowDispenserImg.resize(80, 160);

  froggerIdleImg = loadImage("Images/froggerIdle.png");
  froggerIdleImg.resize(40, 40);

  froggerJumpImg = loadImage("Images/froggerJump.png");
  froggerJumpImg.resize(100, 80);

  crabImg = loadImage("Images/crab.png");
  crabImg.resize(80, 80);
  
  roadImg = loadImage("Images/road.png");
  roadImg.resize(width, pathSize);
  
  smallLogImage = loadImage("Images/smallLog.png");
  bigLogImage = loadImage("Images/bigLog.png");
  coinImage = loadImage("Images/coin.png");
  jetpackImage = loadImage("Images/jetpack.png");
  trainSignalImage = loadImage("Images/trainSignal.png");
  trainSignalLightImage = loadImage("Images/trainSignalLight.png");
  flagImage = loadImage("Images/flag.png");
  scoreTextImage = loadImage("Images/scoreText.png");
  highscoreTextImage = loadImage("Images/highscoreText.png");
  highscoreTextImage.resize(160,60);

  for (int i=0; i<smallCarImgs.length; i++) {
    smallCarImgs[i] = loadImage("Images/car" + (i+1) + ".png");
    smallCarImgs[i].resize(160, 160);
  }

  for (int i=0; i<bigCarImgs.length; i++) {
    bigCarImgs[i] = loadImage("Images/truck" + (i+1) + ".png");
    bigCarImgs[i].resize(100, 200);
  }

  for (int i=0; i<groundTileImgs.length; i++) {
    groundTileImgs[i] = loadImage("Images/tile" + (i+1) + ".png");
    groundTileImgs[i].resize(100, 100);
  }
  
  for (int i=0; i<trainImgs.length; i++) {
    trainImgs[i] = loadImage("Images/train" + (i+1) + ".png");
    trainImgs[i].resize(1000, 80);
  }
  
  for (int i=0; i<gardenStuffImages.length; i++) {
    gardenStuffImages[i] = loadImage("Images/gardenStuff" + (i+1) + ".png");
  }
  
  imageMode(CENTER);
}

public void LoadAllSounds() {
}
class Spawner {
  ArrayList<Obstacle> obstacles = new ArrayList<Obstacle>();

  float yLocation;
  int spawnRate;
  int currentTime;
  int movementDirection;
  int movementSpeed;
  
  Spawner(float yLocation) {
    this.yLocation = yLocation;

    currentTime = floor(random(100));

    // Give the spawner a random direction
    movementDirection = 1;
    if (random(1) < 0.5f) {
      movementDirection = -1;
    }
  }

  public void quickUpdate() {
    for (int i=0; i<200; i++) {
      update();
    }
  }


  public void display() {
    for (Obstacle o : obstacles) {
      o.display();
    }
  }

  public void spawnObstacles() {
    println("Error! " + this + " is spawning obstacles from parent class");
  }


  public void update() {
    currentTime++;
    if (currentTime % spawnRate == 0) {
      spawnObstacles();
      currentTime = 0;
    }

    for (int i=obstacles.size()-1; i>=0; i--) {
      Obstacle o = obstacles.get(i);
      o.update();

      if (o.isFinished()) {
        obstacles.remove(o);
      }
    }
  }

  public void checkCollisions() {
    if (player.location.y < yLocation+pathSize/2 && player.location.y > yLocation-pathSize/2) {
      for (Obstacle o : obstacles) {
        if (o.hitsPlayer()) {
          GameState = 2;
        }
      }
    }
  }

  public void moveDown(int speed) {
    yLocation += speed;
    for (Obstacle o : obstacles) {
      o.moveDown(speed);
    }
  }

  public boolean goesOffscreen() {
    return yLocation > height + pathSize/2 + 100;
  }
  
  public boolean containsPlayer() {
    return player.location.y < yLocation + pathSize/2 &&
      player.location.y > yLocation - pathSize/2;
  }
}


class ArrowTrap extends Spawner {
  ArrowTrap(float yLocation) {
    super(yLocation);

    spawnRate = floor(random(65, 150));
  }

  public void display() {
    imageMode(CENTER);
    for(int x=50; x<width; x+=100) {
      image(groundTileImgs[3], x, yLocation);
    }
    
    super.display();
    
    pushMatrix();
    image(arrowDispenserImg, width-10, yLocation-50);
    translate(10,yLocation-50);
    scale(-1,1);
    image(arrowDispenserImg, 0, 0);
    popMatrix();
  }

  public void spawnObstacles() {
    obstacles.add(new Arrow(-50, yLocation, 1));
    obstacles.add(new Arrow(width+50, yLocation, -1));
  }
}

class CrabSpawner extends Spawner {
  CrabSpawner(float yLocation) {
    super(yLocation);

    movementSpeed = floor(random(3, 6));
    spawnRate = 150 - (movementSpeed-2) * 20;
  }

  public void display() {
    imageMode(CENTER);
    for(int x=50; x<width; x+=100) {
      image(groundTileImgs[1], x, yLocation);
    }

    super.display();
  }

  public void spawnObstacles() {
    float startX = -50;
    if (movementDirection == -1) {
      startX = width + 50;
    }
    obstacles.add(new Crab(startX, yLocation, movementDirection, movementSpeed));
  }
}

class River extends Spawner {
  River(float yLocation, int movementSpeed) {
    super(yLocation);

    this.movementSpeed = movementSpeed;
    spawnRate = 100 - (movementSpeed-2) * 10;
  }

  public void display() {
    imageMode(CENTER);
    for(int x=50; x<width; x+=100) {
      image(groundTileImgs[4], x, yLocation);
    }

    super.display();
  }

  public void spawnObstacles() {
    float startX = -150;
    if (movementDirection == -1) {
      startX = width + 150;
    }
    obstacles.add(new Log(startX, yLocation, movementDirection, movementSpeed));
  }

  public void checkCollisions() {
    if (player.location.y < yLocation+pathSize/2 && player.location.y > yLocation-pathSize/2) {      
      boolean hitsPlayer = false;
      for (Obstacle o : obstacles) {
        if (o.hitsPlayer()) {
          hitsPlayer = true;
        }
      }

      if (hitsPlayer) {
        player.location.y = yLocation;
        player.location.x += movementSpeed * movementDirection;
        player.spriteLocation.x += movementSpeed * movementDirection;
      } else {
        GameState = 2;
      }
    }
  }
}

class BoulderSpawner extends Spawner {
  BoulderSpawner(float yLocation) {
    super(yLocation);

    movementSpeed = floor(random(4, 8));
    spawnRate = 150 - (movementSpeed-2) * 15;
  }

  public void display() {
    imageMode(CENTER);
    for(int x=50; x<width; x+=100) {
      image(groundTileImgs[2], x, yLocation);
    }

    super.display();
  }

  public void spawnObstacles() {
    float startX = -pathSize*0.8f;
    if (movementDirection == -1) {
      startX = width + pathSize*0.8f;
    }
    obstacles.add(new Boulder(startX, yLocation, movementDirection, movementSpeed));
  }
}


class Road extends Spawner {
  int roadStartX;
  Road(float yLocation) {
    super(yLocation);

    movementSpeed = floor(random(3, 8));
    spawnRate = 150 - (movementSpeed-2) * 10;

    roadStartX = floor(random(200)) * -1;
  }

  public void display() {
    imageMode(CENTER);
    image(roadImg, width/2, yLocation);

    super.display();
  }

  public void spawnObstacles() {
    float startX = -150;
    if (movementDirection == -1) {
      startX = width + 150;
    }
    obstacles.add(new Car(startX, yLocation, movementDirection, movementSpeed));
  }
}


class TrainTrack extends Spawner {
  TrainTrack(float yLocation) {
    super(yLocation);

    spawnRate = floor(random(150, 300));
  }

  public void display() {
    imageMode(CENTER);
    for(int x=50; x<width; x+=100) {
      image(groundTileImgs[5], x, yLocation);
    }
    
    super.display();


    image(trainSignalImage,50,yLocation-40);
    noStroke();
    if (currentTime > spawnRate * 0.8f) {
      if (floor(PApplet.parseFloat(frameCount)/5) % 2 == 0) {
        image(trainSignalLightImage, 30, yLocation-16);
      } else {
        image(trainSignalLightImage, 80, yLocation-16);
      }
    }
  }

  public void spawnObstacles() {
    float startX = -width/1.5f;
    if (movementDirection == -1) {
      startX = width + width/1.5f;
    }
    obstacles.add(new Train(startX, yLocation, movementDirection));
  }
}
public void keyPressed() {
  switch(GameState) {
  case 0:
    if (keyCode == UP) {
      GameState = 1;
      player.move(0, -1);
    }
    break;
  case 1:
    switch(keyCode) {
    case UP:
      player.move(0, -1);
      break;
    case DOWN:
      player.move(0, 1);
      break;
    case LEFT:
      player.move(-1, 0);
      break;
    case RIGHT:
      player.move(1, 0);
      break;
    }
    break;
  case 2:
    if (key == 'r') {
      Reset();
    }
    break;
  }
}


public void Reset() {
  GameState = 0;

  if (score > highscore) {
    highscore = score;
    String[] s = {str(highscore)};
    saveStrings("HIGHSCORE.txt", s);
  }
  score = 0;
  player = new Player();
  spawners.clear();
  coins.clear();
  boosters.clear();
  spaceBetweenPaths = floor(random(2, 5));
  coinScoreAlpha = 0;
  createNextSpawner(100);
}


  public void settings() { size(700, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Frogger" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
